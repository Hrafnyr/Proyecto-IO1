/*
 PENDIENTE VALIDAR QUE DATOS DE NUMEROS VENGAN SIN ESPACIO ENTRE DIGITOS
 */
package efficax;

import java.awt.Font;
import java.awt.Image;
import java.awt.List;
import java.util.ArrayList;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;

/**
 *
 * @author Moises
 */
public class menuOptions1 extends javax.swing.JFrame {

    //Variables globales
    int TotalCursos=0;
    int variablesC=0;
    int contStop=0;
    public static double valorZ=0;
    public static ArrayList<classVariable> variablesData = new ArrayList();
    ArrayList<String> variablesArticiales = new ArrayList();
    ArrayList<ArrayList> matriz = new ArrayList();
    ArrayList<celda> funcionObjetivo = new ArrayList<>(); //-ax1-bx2...0s1,0s2...1R1+1R2....
    
    public menuOptions1() {
        initComponents();
        SetImage1();
        this.setLocationRelativeTo(null);
        setHeader();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        txtArea = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        txtTotalCursos = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        myButton2 = new efficax.MyButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        dataTable1 = new javax.swing.JTable();
        myButton3 = new efficax.MyButton();
        myButton4 = new efficax.MyButton();
        backButton1 = new efficax.MyButton();
        myButton6 = new efficax.MyButton();
        txtHoras = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        labelImage1 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        txtCursos1 = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Minimizar tiempo de estudio");
        setResizable(false);

        jPanel1.setBackground(new java.awt.Color(216, 248, 251));
        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        txtArea.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        txtArea.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtAreaActionPerformed(evt);
            }
        });
        jPanel1.add(txtArea, new org.netbeans.lib.awtextra.AbsoluteConstraints(60, 160, 210, 30));

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel1.setText("Área de estudio");
        jPanel1.add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(100, 120, 130, 30));

        txtTotalCursos.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jPanel1.add(txtTotalCursos, new org.netbeans.lib.awtextra.AbsoluteConstraints(560, 380, 110, 30));

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel2.setText("Total de cursos a llevar");
        jPanel1.add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(360, 380, 200, 30));

        myButton2.setBackground(new java.awt.Color(255, 255, 102));
        myButton2.setText("Agregar");
        myButton2.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        myButton2.setRadius(35);
        myButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                myButton2ActionPerformed(evt);
            }
        });
        jPanel1.add(myButton2, new org.netbeans.lib.awtextra.AbsoluteConstraints(680, 220, 190, 40));

        dataTable1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        dataTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Área de estudio", "Cantidad mínima de cursos", "Tiempo en horas a dedicar por curso"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        dataTable1.getTableHeader().setReorderingAllowed(false);
        jScrollPane2.setViewportView(dataTable1);
        if (dataTable1.getColumnModel().getColumnCount() > 0) {
            dataTable1.getColumnModel().getColumn(0).setPreferredWidth(185);
            dataTable1.getColumnModel().getColumn(1).setPreferredWidth(160);
            dataTable1.getColumnModel().getColumn(2).setPreferredWidth(200);
        }

        jPanel1.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 220, 640, 150));

        myButton3.setBackground(new java.awt.Color(120, 253, 218));
        myButton3.setText("Borrar datos");
        myButton3.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        myButton3.setRadius(35);
        myButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                myButton3ActionPerformed(evt);
            }
        });
        jPanel1.add(myButton3, new org.netbeans.lib.awtextra.AbsoluteConstraints(680, 320, 190, 40));

        myButton4.setBackground(new java.awt.Color(154, 246, 73));
        myButton4.setForeground(new java.awt.Color(51, 51, 51));
        myButton4.setText("Calcular");
        myButton4.setFont(new java.awt.Font("Tahoma", 1, 20)); // NOI18N
        myButton4.setRadius(35);
        myButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                myButton4ActionPerformed(evt);
            }
        });
        jPanel1.add(myButton4, new org.netbeans.lib.awtextra.AbsoluteConstraints(700, 390, 160, 50));

        backButton1.setBackground(new java.awt.Color(102, 0, 102));
        backButton1.setForeground(new java.awt.Color(255, 255, 255));
        backButton1.setText("Regresar");
        backButton1.setFont(new java.awt.Font("Calibri", 1, 24)); // NOI18N
        backButton1.setRadius(35);
        backButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                backButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(backButton1, new org.netbeans.lib.awtextra.AbsoluteConstraints(30, 390, 130, 50));

        myButton6.setBackground(new java.awt.Color(252, 218, 81));
        myButton6.setText("Borrar fila seleccionada");
        myButton6.setFont(new java.awt.Font("Tahoma", 1, 13)); // NOI18N
        myButton6.setRadius(35);
        myButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                myButton6ActionPerformed(evt);
            }
        });
        jPanel1.add(myButton6, new org.netbeans.lib.awtextra.AbsoluteConstraints(680, 270, 190, 40));

        txtHoras.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        txtHoras.setToolTipText("");
        jPanel1.add(txtHoras, new org.netbeans.lib.awtextra.AbsoluteConstraints(590, 160, 210, 30));

        jPanel2.setBackground(new java.awt.Color(0, 102, 102));

        jLabel4.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("INGRESO DE DATOS");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGap(65, 65, 65)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 348, Short.MAX_VALUE)
                .addComponent(labelImage1, javax.swing.GroupLayout.PREFERRED_SIZE, 113, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(28, 28, 28))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, 53, Short.MAX_VALUE)
                .addGap(22, 22, 22))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelImage1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        jPanel1.add(jPanel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 880, 100));

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel5.setText("a dedicar por curso");
        jPanel1.add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(620, 130, -1, 30));

        jLabel6.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel6.setText("Tiempo en horas ");
        jPanel1.add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(630, 110, -1, 30));

        txtCursos1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jPanel1.add(txtCursos1, new org.netbeans.lib.awtextra.AbsoluteConstraints(330, 160, 210, 30));

        jLabel3.setFont(new java.awt.Font("Tahoma", 1, 16)); // NOI18N
        jLabel3.setText("Cantidad mínima de cursos");
        jPanel1.add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(320, 120, 220, 30));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 885, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 459, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void txtAreaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtAreaActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_txtAreaActionPerformed

    private void backButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backButton1ActionPerformed
        // TODO add your handling code here:
        MainWindow principal = new MainWindow();
        principal.setVisible(true);
        this.setVisible(false);
    }//GEN-LAST:event_backButton1ActionPerformed

    private void myButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_myButton2ActionPerformed
        //Agregando datos a la tabla y validando campos
        String area      = this.txtArea.getText();
        String cantidad  = this.txtCursos1.getText();
        String horas     = this.txtHoras.getText();
        
        //Validar campos llenos
        try {
            if(area.equals("") || cantidad.equals("") || horas.equals("")){
                JOptionPane.showMessageDialog(
                    this, "Debe llenar todos los campos");
            }
            else
                //Validar que cantidad y horas sean de tipo int y mayores a 0
                if(search_digit(cantidad)==false){
                    JOptionPane.showMessageDialog(
                            this, "La cantidad debe ser un número");
                }else if(Double.parseDouble(cantidad)<=0){
                    JOptionPane.showMessageDialog(
                            this, "La cantidad debe ser positiva");
                }

                else
                    if(search_digit(horas)==false){
                        JOptionPane.showMessageDialog(
                            this, "El tiempo debe ser un número");
                    }else if(Double.parseDouble(horas)<=0){
                        JOptionPane.showMessageDialog(
                            this, "Las horas deben ser positivas");
                    }

                    else{
                        System.out.println("Todo bien");
                        addNewItem(area, cantidad, horas);
                    }
        } catch (Exception e) {
            JOptionPane.showMessageDialog(
                            this, "Los datos ingresados no son válidos");
        }
    }//GEN-LAST:event_myButton2ActionPerformed

    private void myButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_myButton3ActionPerformed
        cleanTable();
    }//GEN-LAST:event_myButton3ActionPerformed

    private void myButton6ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_myButton6ActionPerformed
        deleteEspecificRow();
    }//GEN-LAST:event_myButton6ActionPerformed

    private void myButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_myButton4ActionPerformed
        // TODO add your handling code here:
        String cursosT = this.txtTotalCursos.getText();
        
        if(cursosT.equals("")){
            JOptionPane.showMessageDialog(
                this, "Debe indicar el total de cursos que debe llevar");
        }else
            if(this.dataTable1.getRowCount()==0){
                JOptionPane.showMessageDialog(
                    this, "No se han agregado datos a la tabla");
            }
            else
                if(this.dataTable1.getRowCount()==1){
                    JOptionPane.showMessageDialog(
                        this, "Debe ingresar mínimo 2 datos");
                }
                else{
                    //validar que cant de curso sea > que la suma
                    int sumaParcial=0;
                    for (int i = 0; i < this.dataTable1.getRowCount(); i++) {
                        sumaParcial+= Integer.parseInt(
                                      String.valueOf(this.dataTable1.getValueAt(i,1)));
                    }
                    int t=Integer.parseInt(this.txtTotalCursos.getText());
                    if(t<=sumaParcial){
                        JOptionPane.showMessageDialog(
                            this, "El total de cursos debe ser mayor a la suma de la cantidad mínima de cursos de cada área");
                    }
                    else{
                        System.out.println("Todo bien");
                        getDatafromTable();
                        TotalCursos=Integer.parseInt(this.txtTotalCursos.getText());
                    }
                }    
    }//GEN-LAST:event_myButton4ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(menuOptions1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(menuOptions1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(menuOptions1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(menuOptions1.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new menuOptions1().setVisible(true);
            }
        });
    }
    
    private void setHeader(){
        JTableHeader th;
        th = this.dataTable1.getTableHeader();
        Font fuente = new Font("Verdana", Font.BOLD,12);
        th.setFont(fuente);
    }
    
    private void SetImage1(){
        ImageIcon image = new ImageIcon(
                            getClass().getResource("/images/imageR1.png"));
        Icon icon = new ImageIcon(
                        image.getImage().getScaledInstance(
                                this.labelImage1.getWidth(), 
                                this.labelImage1.getHeight(), 
                                Image.SCALE_DEFAULT));
        this.labelImage1.setIcon(icon);
        this.repaint();
    }
    
    private boolean search_digit(String s){
  
        // Function to check if is digit
        // is found or not
        for (int i = 0; i < s.length(); i++) {
            if (Character.isDigit(
                    s.charAt(i))
                == true) {
                // return position of digit
                return true;
            }
        }
        // return 0 if digit not present
        return false;
    }
    
    private void addNewItem(
            String nombre, String cantidad, String tiempo){
        
        DefaultTableModel model = 
                (DefaultTableModel) this.dataTable1.getModel();
        
        String newRow [] = {nombre.trim(),cantidad.trim(),tiempo.trim()};
        model.addRow(newRow);
        this.dataTable1.setRowHeight(35);
        
        //Clean text field
        this.txtArea.setText("");
        this.txtCursos1.setText("");
        this.txtHoras.setText("");
    }
    
        private void cleanTable(){
        DefaultTableModel model = 
                (DefaultTableModel) this.dataTable1.getModel();
        
        model.setRowCount(0);
        //Clean text field
        this.txtArea.setText("");
        this.txtCursos1.setText("");
        this.txtHoras.setText("");
    }
    
    private void deleteEspecificRow(){
        
        DefaultTableModel model = 
                (DefaultTableModel) this.dataTable1.getModel(); 
        
        int a = dataTable1.getSelectedRow(); 
 
        if (a<0){ 
            JOptionPane.showMessageDialog(this, 
                        "Debe seleccionar una fila de la tabla" ); 

        }else {
            int confirmar=JOptionPane.showConfirmDialog(null, 
                        "¿Eliminar el registro? "); 
 
            if(JOptionPane.OK_OPTION==confirmar) {
                model.removeRow(a); 
                JOptionPane.showMessageDialog(this,"Registro Eliminado" );
            } 
        } 
    }
    
    //Metodos para aplicar 2 fases
    
    private void getDatafromTable(){
        int contVariables=0;
        for (int i = 0; i < this.dataTable1.getRowCount(); i++) {
            contVariables++;
            variablesData.add(
                new classVariable(
                    "X"+String.valueOf(contVariables), //id
                    String.valueOf(this.dataTable1.getValueAt(i,0)), //name
                    0, //valor inicial
                    Integer.parseInt(
                        String.valueOf(this.dataTable1.getValueAt(i,1))), //cantidad minima de curso
                    Integer.parseInt(
                        String.valueOf(this.dataTable1.getValueAt(i,2))), //cantidad de horas implicadas
                    "S"+String.valueOf(contVariables+1),  //exceso
                    "R"+String.valueOf(contVariables+1) //artificial
                )
            );
        }
        variablesC=contVariables;
        System.out.println(
                "Trabajar con "+String.valueOf(contVariables)+" variables");
        
        //Crear la matriz
        createMatrix();
        
    }
    
    private void createMatrix(){
        
        //fila R0, fila R1 (x+y=T), y filas por cada variable
        int fila=2+variablesC; 
        int cursos=Integer.parseInt(this.txtTotalCursos.getText());
        //columnas x1,x2..,s2,s3...,R1,r2,r3...,Solucion
        int columna=(variablesC*3)+2;
        int cont=0;
        
        for (int i = 0; i < fila; i++) {
            ArrayList<celda> filaM = new ArrayList();
            //Primer fila es de R0
            if (i==0) {
                //5 vueltas
                for (int t = 0; t < 5; t++) {
                    //vuelta 1 para agregar variables
                    if (t==0) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R0",variablesData.get(a).id,0));
                        }
                    }
                    //vuelta 2 para agregar exceso
                    if (t==1) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R0",variablesData.get(a).exceso,0));
                        }
                    }
                    //vuelta 3 para agregar R1
                    if (t==2) {
                        filaM.add(
                            new celda("R0","R1",-1));
                    }
                    //vuelta 4 para agregar artificiales
                    if (t==3) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R0",variablesData.get(a).artificial,-1));
                        }
                    }
                    //vuelta 5 para agregar solucion
                    if (t==4) {
                        filaM.add(
                            new celda("R0","solucion",0));
                    }
                }
                //agregar a matriz
                matriz.add(filaM);
                //limpiar fila
                //filaM.clear();
            }
            //Fila 2 es para R1
            else if (i==1) {
                //5 vueltas
                for (int t = 0; t < 5; t++) {
                    //vuelta 1 para agregar variables
                    if (t==0) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R1",variablesData.get(a).id,1));
                        }
                    }
                    //vuelta 2 para agregar exceso
                    if (t==1) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R1",variablesData.get(a).exceso,0));
                        }
                    }
                    //vuelta 3 para agregar R1
                    if (t==2) {
                        filaM.add(
                            new celda("R1","R1",1));
                    }
                    //vuelta 4 para agregar artificiales
                    if (t==3) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            filaM.add(
                            new celda("R1",variablesData.get(a).artificial,0));
                        }
                    }
                    //vuelta 5 para agregar solucion
                    if (t==4) {
                        filaM.add(
                            new celda("R1","solucion",cursos));
                    }
                }
                //agregar a matriz
                matriz.add(filaM);
                //limpiar fila
                //filaM.clear();
            }
            //En caso contrario las demás filas corresponden a variables
            //artificiales de cada variable
            else{
                for (int t = 0; t < 5; t++) {
                    //vuelta 1 para agregar variables
                    if (t==0) {
                        for (int a = 0; a < variablesData.size(); a++) {
                            if(a==cont){
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).id,1));
                            }
                            else{
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).id,0));
                            }
                        }
                    }
                    //vuelta 2 para agregar exceso
                    if (t==1) {
                        for (int a = 0; a < variablesData.size(); a++) {
                             if(a==cont){
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).exceso,-1));
                            }
                            else{
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).exceso,0));
                            }
                        }
                    }
                    //vuelta 3 para agregar R1
                    if (t==2) {
                        filaM.add(
                            new celda(variablesData.get(cont).artificial,
                                        "R1",0));
                    }
                    //vuelta 4 para agregar artificiales
                    if (t==3) {
                        for (int a = 0; a < variablesData.size(); a++) {
                             if(a==cont){
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).artificial,1));
                            }
                            else{
                                filaM.add(
                                new celda(variablesData.get(cont).artificial,
                                        variablesData.get(a).artificial,0));
                            }
                        }
                    }
                    //vuelta 5 para agregar solucion
                    if (t==4) {
                        filaM.add(
                            new celda(variablesData.get(cont).artificial,
                                "solucion",variablesData.get(cont).cantMin));
                    }
                }
                //agregar a matriz
                matriz.add(filaM);
                //limpiar fila
                //filaM.clear();
                cont++;
            }
            
        }
        
        showMatrix(columna);
        
        //Guardar las variables artificiales para comparar en fase 1
        variablesArticiales.add("R1");
        for (int i = 0; i < variablesData.size(); i++) {
            variablesArticiales.add(variablesData.get(i).artificial);
        }
        startFase1();
    }
    
    private void showMatrix(int columnas){
        System.out.println("Mostrando matriz");
        int cont=0;
        for(ArrayList<celda> arr : matriz) {
            for(celda i : arr) {
                //System.out.print(i.fila);
                //System.out.print(i.columna);
                //System.out.print("    ");
                System.out.print(i.valor);
                System.out.print("    ");
            }
            System.out.println("");
        }
    }
    
    private void startFase1(){
        
        //Paso 1, sumar R0 (fila 1) con las demás filas
        
        ArrayList<celda> arr = matriz.get(0); //Capturar fila 1
        
        for (int i = 1; i < matriz.size(); i++) { //Recorrer demás filas
            ArrayList<celda> aux = matriz.get(i); //Capturar fila n
            
            //Recorrer elementos para sumar los valores fila 1  y siguiente
            for (int j = 0; j < arr.size(); j++) {
                double nuevoValor= arr.get(j).valor+aux.get(j).valor;
                arr.get(j).setValor(nuevoValor);
            }
            System.out.println("");
        }
                
        showMatrix(0);
        
        //Llamada de método recursivo que permite aplicar algoritmo de 1 fase
        fase1();
    }
    
    private void fase1(){
        
        //Hallar el más positivo 
        ArrayList<celda> arr = matriz.get(0); //Capturar fila 1
        
        //Buscar el más positivo
        int index=1;
        String column_b=arr.get(0).columna;
        double mayor = arr.get(0).valor;
        while (index < arr.size()-1) {    
            
            if (arr.get(index).valor > mayor) {
                    System.out.println("Entrando");
                    mayor = arr.get(index).valor;
                    column_b = arr.get(index).columna;
                    System.out.println(column_b);
            }
            index++;
        }
        if(mayor > 0){ //El valor mayor siempre deber ser positivo, de no cumplir pasa a verificar la condicion
        
            System.out.println("Columna pivote:"+column_b);

            //Ahora se hace prueba del cociente:
            double numerador=0;
            double denominador=0;
           
            //Ahora se analiza la prueba
            celda tmp=null;
            int indiceTMP=1;
            
            ArrayList<Double> datosC = new ArrayList<>(); //guardar cocientes
            ArrayList<Integer> indicesC = new ArrayList<>(); //guardar indices
            ArrayList<celda> menores = new ArrayList<>(); //guardar cocientes menores
            
            for (int i = 1; i < matriz.size(); i++) { //Recorrer demás filas
                ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                //Recorrer elementos de fila para obtener celdas
                int c=0;
                for (int j = 0; j < aux.size(); j++) {
                    if(aux.get(j).columna.equals(column_b)){ //hallar columna
                        //datosC.add(aux.get(j));
                        denominador=aux.get(j).valor;
                        c=j;
                    }
                    if(aux.get(j).columna.equals("solucion")){
                        //solucionesC.add(aux.get(j));
                        numerador=aux.get(j).valor;
                    }
                }
                
                //validar solo positivos
                if(numerador>0 && denominador > 0){
                    double total= numerador/denominador;
                    indiceTMP=i;
                    datosC.add(total);
                    indicesC.add(indiceTMP);
                    menores.add(aux.get(c)); //guardar la celda 
                }
                
            }            
            
            double menor=datosC.get(0);

            System.out.println("Valor menor inicial:"+menor);
            int tt=0;
            if(datosC.size()==1){
                tmp=menores.get(0);
                tt=indicesC.get(0);
            }
            else{
                for (int i = 1; i < datosC.size(); i++) {  
                    double actual=datosC.get(i);
                    System.out.println("Valor siguiente:"+actual);

                    if(actual < menor) {
                        menor=actual;
                        tmp=menores.get(i);
                        tt=indicesC.get(i);
                    }
                }
            }
            
            System.out.println("El elegido es: "+tmp.valor+",en fila: "+tmp.fila+" y columna: "+tmp.columna);
            System.out.println("Fila en matriz: "+tt);

            //Ahora se verifica que el valor de celda sea 1, sino hacerlo 1 y operar toda la fila
            if(tmp.valor==1){
                System.out.println("El valor ya es 1, seguir");
            }
            else{
                System.out.println("El valor no es 1, dividir");
                for (int i = 1; i < matriz.size(); i++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                            double nuevoValor= aux.get(j).valor/tmp.valor;
                            aux.get(j).setValor(nuevoValor);
                        }
                    }
                }
            }

            //Luego hacer 0 celdas de arriba y abajo, implica operar demás valores de filas
            ArrayList<celda> pivote = matriz.get(tt); //Capturar fila pivote

            ArrayList<Double> pivC = new ArrayList<>(); //lista con elementos de la columna pivote
            for (int i = 0; i < matriz.size(); i++) { //Recorrer demás filas
                ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                //Recorrer elementos de fila para obtener celdas
                for (int j = 0; j < aux.size(); j++) {
                    if(aux.get(j).columna.equals(tmp.columna)){ //hallar columna
                        pivC.add(aux.get(j).valor);
                    }
                }
            }

            for (int i = 0; i < matriz.size(); i++) { //Recorrer demás filas
                ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                //Recorrer elementos de fila para obtener celdas
                for (int j = 0; j < aux.size(); j++) {
                    if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                        System.out.println("->");
                    }
                    else{
                        //Verificamos si el valor de celda es positivo
                        if(pivC.get(i) > 0){
                            double nuevoD=aux.get(j).valor-(pivC.get(i)*pivote.get(j).valor);

                            aux.get(j).setValor(nuevoD);
                        }
                        //verificamos si el valor de celda es negativo
                        else if(pivC.get(i)<0){
                            double nuevoD=aux.get(j).valor+(pivC.get(i)*pivote.get(j).valor*-1);
                            aux.get(j).setValor(nuevoD);
                        }
                    }    
                }
            }

            //Por ultimo sale artificial de base y entra nueva variable
            String aux=tmp.columna;
            for (int i = 0; i < pivote.size(); i++) {
                pivote.get(i).setFila(aux);
            }
            
            showMatrix(0);
            fase1();
        }
        else{
            //Si no quedan numero positivos se verifica condiciones de parada
            //Primero es que la solucion sea cero:
            ArrayList<celda> aux = matriz.get(0); //Capturar fila n
            boolean flag1=false;
            for (int i = 0; i < aux.size(); i++) {
                if(aux.get(i).columna.equals("solucion")){
                    if(aux.get(i).valor==0){
                        flag1=true;
                    }
                }
            } //si flag1 sigue false es porque la solucion NO es cero
            
            boolean flag2=false;
            //Segunda condicion, que en la base no haya variables artificiales
            for (int i = 0; i < matriz.size(); i++) { //Recorrer demás filas
                ArrayList<celda> fila = matriz.get(i); //Capturar fila n

                //basta con saber la fila del primer elemento
                for (int j = 0; j < variablesArticiales.size(); j++) {
                    if(variablesArticiales.get(j).equals(fila.get(0).fila)){
                        flag2=true;
                    }
                }
            } //Si flag2 sigue false es porque no hay variables artificiales
            
            //analisis
            if(flag1 == false && flag2 == true){
                System.out.println("No hay solucion");
            }
            else{
                System.out.println("Fase 1 terminada...");
                startFase2();
            }
            
        } 
    }
    
    private void startFase2(){
        System.out.println("Iniciando fase 2...");
        //Construir la fila de funcion objetivo
        //Recorrer elementos de fila para obtener celdas
        ArrayList<celda> aux = matriz.get(0); //Fila de R0, debe cambiarse a Z
        
        int cont=0;
        for (int i = 0; i < aux.size(); i++) {
            //vuelta 1 cambiar fila a z y valores negativos de coeficientes
            if(cont==0){
              
                for (int j = 0; j < variablesC; j++) {
                    aux.get(i).setFila("Z");
                    double valor= (double)variablesData.get(j).horas*-1;
                    aux.get(i).setValor(valor);
                    i++;
                }
                cont++;
            }
            //vuelta 2 cambiar fila a z y valores exceso a 0
            if(cont==1){
                for (int j = 0; j < variablesC; j++) {
                    aux.get(i).setFila("Z");
                    aux.get(i).setValor(0);
                    i++;
                }
                cont++;
            }
            
            //Como solo interesa cambiar los valores de variables y exceso
            //no se modifica las R ni la solucion que en este punto ya es 0
            aux.get(i).setFila("Z");
            //System.out.println(aux.get(i).columna);
        }
        showMatrix(0);
        
        //Segundo paso antes de ejecutar el metodo simplex
        //hacer que elementos de variables básicas tengan valor cero
        ajustarBasicas();
        
        
    }
    
    private void ajustarBasicas(){
        //Recorrer por columna la cantidad de variables
        //recorrer filas de cada columna, hallar prueba de cociente, hacer 1 si no esta y operar la fila
        
        ArrayList<celda> arr = matriz.get(0); //Capturar fila 1
        ArrayList<celda> basicas = new ArrayList<>(); //Lista con las celdas de var_básicas que deben hacerse cero
        
        for (int i = 0; i < variablesC; i++) {
            if (arr.get(i).valor!=0) {
                basicas.add(arr.get(i));
            }
        }
        
        //Verificar si existen datos para hacer cero
        if (basicas.size()>0) {
            //Hacer prueba de cociente recorriendo las filas de abajo en la misma columna
            for (int i = 0; i < basicas.size(); i++) {
                System.out.println("Columna actual:"+basicas.get(i).columna);
                //Ahora se hace prueba del cociente:
                double numerador=0;
                double denominador=0;

                //Ahora se analiza la prueba
                celda tmp=null;
                int indiceTMP=1;
                
                ArrayList<Double> datosC = new ArrayList<>(); //guardar cocientes
                ArrayList<Integer> indicesC = new ArrayList<>(); //guardar indices
                ArrayList<celda> menores = new ArrayList<>(); //guardar cocientes menores
                
                for (int x = 1; x < matriz.size(); x++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(x); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    int c=0;
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).columna.equals(basicas.get(i).columna)){ //hallar columna
                            //datosC.add(aux.get(j));
                            denominador=aux.get(j).valor;
                            c=j;
                        }
                        if(aux.get(j).columna.equals("solucion")){
                            //solucionesC.add(aux.get(j));
                            numerador=aux.get(j).valor;
                        }
                    }

                    //validar solo positivos
                    if(numerador>0 && denominador > 0){
                        double total= numerador/denominador;
                        indiceTMP=x;
                        datosC.add(total);
                        indicesC.add(indiceTMP);
                        menores.add(aux.get(c)); //guardar la celda 
                    }

                }            

                double menor=datosC.get(0);

                System.out.println("Valor menor inicial:"+menor);
                int tt=0;
                if(datosC.size()==1){
                    tmp=menores.get(0);
                    tt=indicesC.get(0);
                }
                else{
                    for (int t = 1; t < datosC.size(); t++) {  
                        double actual=datosC.get(t);
                        System.out.println("Valor siguiente:"+actual);

                        if(actual < menor) {
                            menor=actual;
                            tmp=menores.get(t);
                            tt=indicesC.get(t);
                        }
                    }
                }

                System.out.println("El elegido es: "+tmp.valor+",en fila: "+tmp.fila+" y columna: "+tmp.columna);
                System.out.println("Fila en matriz: "+tt);

                //Ahora se verifica que el valor de celda sea 1, sino hacerlo 1 y operar toda la fila
                if(tmp.valor==1){
                    System.out.println("El valor ya es 1, seguir");
                }
                else{
                    System.out.println("El valor no es 1, dividir");
                    for (int f = 1; f < matriz.size(); f++) { //Recorrer demás filas
                        ArrayList<celda> aux = matriz.get(f); //Capturar fila n

                        //Recorrer elementos de fila para obtener celdas
                        for (int j = 0; j < aux.size(); j++) {
                            if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                                double nuevoValor= aux.get(j).valor/tmp.valor;
                                aux.get(j).setValor(nuevoValor);
                            }
                        }
                    }
                }

                //Luego hacer 0 celdas de arriba y abajo, implica operar demás valores de filas
                ArrayList<celda> pivote = matriz.get(tt); //Capturar fila pivote
                ArrayList<Double> pivC = new ArrayList<>(); //lista con elementos de la columna pivote
                for (int w = 0; w < matriz.size(); w++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(w); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).columna.equals(tmp.columna)){ //hallar columna
                            pivC.add(aux.get(j).valor);
                        }
                    }
                }

                for (int p = 0; p < matriz.size(); p++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(p); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                            System.out.println("->");
                        }
                        else{
                            //Verificamos si el valor de celda es positivo
                            if(pivC.get(p) > 0){
                                double nuevoD=aux.get(j).valor-(pivC.get(p)*pivote.get(j).valor);

                                aux.get(j).setValor(nuevoD);
                            }
                            //verificamos si el valor de celda es negativo
                            else if(pivC.get(p)<0){
                                double nuevoD=aux.get(j).valor+(pivC.get(p)*pivote.get(j).valor*-1);
                                aux.get(j).setValor(nuevoD);
                            }
                        }    
                    }
                }
                showMatrix(0);               
            }
            ajustarBasicas();
        }
        else{
            //Aplicar simplex para ver si existen datos a reducir más
            //Se usará el mismo metodo de fase 1, pero se hará en otra función
            fase2();
        }   
    }
    
    private void fase2(){
        //Hallar el más positivo sin contar las artificiales ni solucion
        ArrayList<celda> arr = matriz.get(0); //Capturar fila 1
        
        //Buscar el más positivo
        int index=1;
        String column_b=arr.get(0).columna;
        double mayor = arr.get(0).valor;
        //Es decir que sería: cantVaribles*2
        int stop = variablesC*2;
        
        while (index < stop) {    
            double siguiente = arr.get(index).valor;
            if ( siguiente > mayor) {
                    System.out.println("Entrando");
                    mayor = siguiente;
                    column_b = arr.get(index).columna;
                    System.out.println(column_b);
            }
            index++;
        }
        System.out.println("Mayor encontrado:"+mayor);
        if(mayor > 0){ //El valor mayor siempre deber ser positivo, de no cumplir pasa a verificar la condicion
        
            System.out.println("Columna pivote:"+column_b);

            //Ahora se hace prueba del cociente:
            double numerador=0;
            double denominador=0;
           
            //Ahora se analiza la prueba
      
            int indiceTMP=1;
            
            ArrayList<Double> datosC = new ArrayList<>(); //guardar cocientes
            ArrayList<Integer> indicesC = new ArrayList<>(); //guardar indices
            ArrayList<celda> menores = new ArrayList<>(); //guardar cocientes menores
            
            for (int i = 1; i < matriz.size(); i++) { //Recorrer demás filas
                ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                //Recorrer elementos de fila para obtener celdas
                int c=0;
                for (int j = 0; j < aux.size(); j++) {
                    if(aux.get(j).columna.equals(column_b)){ //hallar columna
                        //datosC.add(aux.get(j));
                        denominador=aux.get(j).valor;
                        c=j;
                    }
                    if(aux.get(j).columna.equals("solucion")){
                        //solucionesC.add(aux.get(j));
                        numerador=aux.get(j).valor;
                    }
                }
                
                //validar solo positivos
                if(numerador>0 && denominador > 0){
                    double total= numerador/denominador;
                    indiceTMP=i;
                    datosC.add(total);
                    indicesC.add(indiceTMP);
                    menores.add(aux.get(c)); //guardar la celda 
                }
                
            }            
            
            //Si en Z hay positivo pero sus valores de columnas son 0
            //ignorar columna y buscar otra
            
            if (datosC.size()==0) {
                System.out.println("Cantidad de cocientes validos:"+datosC.size());
            }
            else{ 
                celda tmp=menores.get(0);
                double menor=datosC.get(0);

                System.out.println("Valor menor inicial:"+menor);
                int tt=indicesC.get(0);
                if(datosC.size()==1){
                    tmp=menores.get(0);
                    tt=indicesC.get(0);
                }
                else{
                    for (int i = 1; i < datosC.size(); i++) {  
                        double actual=datosC.get(i);
                        System.out.println("Valor siguiente:"+actual);
                        if(actual < menor) {
                            menor=actual;
                            tmp=menores.get(i);
                            tt=indicesC.get(i);
                        }
                    }
                }

                System.out.println("El elegido es: "+tmp.valor+",en fila: "+tmp.fila+" y columna: "+tmp.columna);
                System.out.println("Fila en matriz: "+tt);

                //Ahora se verifica que el valor de celda sea 1, sino hacerlo 1 y operar toda la fila
                if(tmp.valor==1){
                    System.out.println("El valor ya es 1, seguir");
                }
                else{
                    System.out.println("El valor no es 1, dividir");
                    for (int i = 1; i < matriz.size(); i++) { //Recorrer demás filas
                        ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                        //Recorrer elementos de fila para obtener celdas
                        for (int j = 0; j < aux.size(); j++) {
                            if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                                double nuevoValor= aux.get(j).valor/tmp.valor;
                                aux.get(j).setValor(nuevoValor);
                            }
                        }
                    }
                }

                //Luego hacer 0 celdas de arriba y abajo, implica operar demás valores de filas
                ArrayList<celda> pivote = matriz.get(tt); //Capturar fila pivote

                ArrayList<Double> pivC = new ArrayList<>(); //lista con elementos de la columna pivote
                for (int i = 0; i < matriz.size(); i++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).columna.equals(tmp.columna)){ //hallar columna
                            pivC.add(aux.get(j).valor);
                        }
                    }
                }

                for (int i = 0; i < matriz.size(); i++) { //Recorrer demás filas
                    ArrayList<celda> aux = matriz.get(i); //Capturar fila n

                    //Recorrer elementos de fila para obtener celdas
                    for (int j = 0; j < aux.size(); j++) {
                        if(aux.get(j).fila.equals(tmp.fila)){ //hallar fila
                            System.out.println("->");
                        }
                        else{
                            //Verificamos si el valor de celda es positivo
                            if(pivC.get(i) > 0){
                                double nuevoD=aux.get(j).valor-(pivC.get(i)*pivote.get(j).valor);

                                aux.get(j).setValor(nuevoD);
                            }
                            //verificamos si el valor de celda es negativo
                            else if(pivC.get(i)<0){
                                double nuevoD=aux.get(j).valor+(pivC.get(i)*pivote.get(j).valor*-1);
                                aux.get(j).setValor(nuevoD);
                            }
                        }    
                    }
                }

                //Por ultimo sale artificial de base y entra nueva variable
                String aux=tmp.columna;
                for (int i = 0; i < pivote.size(); i++) {
                    pivote.get(i).setFila(aux);
                }

                showMatrix(0);
                fase2(); //repetir hasta que se cumpla la condición de parada
            }
        }
        else{
                //Si no quedan numero positivos quiere decir que el tablero es óptimo

               // if (contStop<variablesC) {
                 //   System.out.println("Tablero optimo encontrado...");    
                   // contStop++;
                //}
                //else{
                //Se procede a obtener los valores de cada variable así como el resultado final
                System.out.println(" ");

                ArrayList<celda> resultado = matriz.get(0);
                //Solucion Z
                for (int i = 0; i < resultado.size(); i++) {
                    if (resultado.get(i).columna.equals("solucion")) {
                        valorZ=resultado.get(i).valor;
                        System.out.println("Se invertirá "+valorZ+" horas de estudio con la siguiente configuración:");
                    }
                }

                //Se recorre la cantidad de variables, 1 por cada vuelta
                for (int n = 0; n < variablesC; n++) {

                    //en cada vuelta se encuentra la fila de la variable
                    for (int i = 1; i < matriz.size(); i++) {
                        ArrayList<celda> fila = matriz.get(i);

                        if (fila.get(i).fila.equals(variablesData.get(n).id)) {
                            //Cuando se halla la fila, se recorre la columna hasta obtener la solucion
                            for (int j = 0; j < fila.size(); j++) {
                                if (fila.get(j).columna.equals("solucion")) {
                                    double valor = fila.get(j).valor;
                                    variablesData.get(n).setValor(valor);
                                }
                            }
                        }

                    }
                }

                //Una vez hallado los valores, se tiene la informacion de solucion
                for (int i = 0; i < variablesData.size(); i++) {
                    System.out.println(
                        "Para "+variablesData.get(i).name+
                        " corresponden "+variablesData.get(i).valor + " cursos");
                }

                this.setVisible(false);
                resultado1 vR = new resultado1();
                vR.Clear_T(); //limpia tabla
                vR.addNewRow(); //agrega nuevos datos
                vR.showLabel();
                vR.setVisible(true);
               // }
        }
    }
    
    public void clearAll(){
        valorZ=0;
        variablesData.clear();
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private efficax.MyButton backButton1;
    private javax.swing.JTable dataTable1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel labelImage1;
    private efficax.MyButton myButton2;
    private efficax.MyButton myButton3;
    private efficax.MyButton myButton4;
    private efficax.MyButton myButton6;
    private javax.swing.JTextField txtArea;
    private javax.swing.JTextField txtCursos1;
    private javax.swing.JTextField txtHoras;
    private javax.swing.JTextField txtTotalCursos;
    // End of variables declaration//GEN-END:variables
}
